<!doctype html>
<script src="https://zh.js.cx/test/libs.js"></script>
<script>

  // 原版本 - 串行处理响应：流程：请求1 → 等待响应1 → 处理响应1 → 请求2 → 等待响应2 → 处理响应2 → ...
  async function getUsersOriginal(names) {
    let result = [];
    let jobs = names.map(name => fetch(`https://api.github.com/users/${name}`));

    for(let job of jobs) {
      let response = await job; // 这里会阻塞！ 必须等待当前请求完成才处理下一个
      if(response.status != 200) {
        result.push(null);
      } else {
        let json = await response.json();
        result.push(json);
      }
    }
  
    return result;
  }





  // 优化版本 - 并行处理响应：
  // 请求1 ──┐
  // 请求2 ──┼─→ Promise.all() → 同时处理所有响应
  // 请求3 ──┘
  async function getUsers(names) {
    let jobs = names.map(name => 
      fetch(`https://api.github.com/users/${name}`)
        .then(response => {
          if (response.status != 200) {
            return null;
          } else {
            return response.json();
          }
        })
        .catch(() => null)
    );

    return await Promise.all(jobs);
  }

  // 方法一：使用 async/await + Promise.all() 手动优化
  async function getUsersOptimized1(names) {
    // 创建所有请求的Promise数组
    const promises = names.map(async (name) => {
      try {
        const response = await fetch(`https://api.github.com/users/${name}`);
        if (response.status !== 200) {
          return null;
        }
        return await response.json();
      } catch (error) {
        return null;
      }
    });

    // 并行等待所有Promise完成
    return await Promise.all(promises);
  }

  // 方法二：使用 async/await + Promise.allSettled() 手动优化
  async function getUsersOptimized2(names) {
    const promises = names.map(async (name) => {
      const response = await fetch(`https://api.github.com/users/${name}`);
      if (response.status !== 200) {
        return null;
      }
      return await response.json();
    });

    const results = await Promise.allSettled(promises);
    return results.map(result => 
      result.status === 'fulfilled' ? result.value : null
    );
  }

  // 方法三：使用 async/await + 手动创建Promise数组
  async function getUsersOptimized3(names) {
    // 先创建所有请求，但不等待
    const fetchPromises = names.map(name => fetch(`https://api.github.com/users/${name}`));
    
    // 并行等待所有fetch完成
    const responses = await Promise.all(fetchPromises);
    
    // 处理所有响应
    const jsonPromises = responses.map(async (response) => {
      if (response.status !== 200) {
        return null;
      }
      return await response.json();
    });
    
    // 并行等待所有JSON解析完成
    return await Promise.all(jsonPromises);
  }

  // 性能测试函数
  async function performanceTest() {
    const testNames = ['iliakan', 'remy', 'no.such.users', 'octocat', 'defunkt'];
    
    console.log('开始性能测试...');
    console.log('测试用户:', testNames);
    
    // 测试原版本（串行）
    console.log('\n=== 测试原版本 (串行处理) ===');
    const startTime1 = performance.now();
    const result1 = await getUsersOriginal(testNames);
    const endTime1 = performance.now();
    const time1 = endTime1 - startTime1;
    console.log(`原版本耗时: ${time1.toFixed(2)}ms`);
    console.log('结果:',result1,result1.map(user => user ? user.login : null));
    
    // 测试then版本（并行）
    console.log('\n=== 测试then版本 (并行处理) ===');
    const startTime2 = performance.now();
    const result2 = await getUsers(testNames);
    const endTime2 = performance.now();
    const time2 = endTime2 - startTime2;
    console.log(`then版本耗时: ${time2.toFixed(2)}ms`);
    console.log('结果:', result2.map(user => user ? user.login : null));
    
    // 测试async/await优化版本1
    console.log('\n=== 测试async/await优化版本1 ===');
    const startTime3 = performance.now();
    const result3 = await getUsersOptimized1(testNames);
    const endTime3 = performance.now();
    const time3 = endTime3 - startTime3;
    console.log(`优化版本1耗时: ${time3.toFixed(2)}ms`);
    console.log('结果:', result3.map(user => user ? user.login : null));
    
    // 测试async/await优化版本2
    console.log('\n=== 测试async/await优化版本2 ===');
    const startTime4 = performance.now();
    const result4 = await getUsersOptimized2(testNames);
    const endTime4 = performance.now();
    const time4 = endTime4 - startTime4;
    console.log(`优化版本2耗时: ${time4.toFixed(2)}ms`);
    console.log('结果:', result4.map(user => user ? user.login : null));
    
    // 测试async/await优化版本3
    console.log('\n=== 测试async/await优化版本3 ===');
    const startTime5 = performance.now();
    const result5 = await getUsersOptimized3(testNames);
    const endTime5 = performance.now();
    const time5 = endTime5 - startTime5;
    console.log(`优化版本3耗时: ${time5.toFixed(2)}ms`);
    console.log('结果:', result5.map(user => user ? user.login : null));
    
    // 性能对比
    console.log('\n=== 性能对比总结 ===');
    console.log(`原版本(串行): ${time1.toFixed(2)}ms`);
    console.log(`then版本(并行): ${time2.toFixed(2)}ms - 提升${((time1-time2)/time1*100).toFixed(2)}%`);
    console.log(`async/await优化1: ${time3.toFixed(2)}ms - 提升${((time1-time3)/time1*100).toFixed(2)}%`);
    console.log(`async/await优化2: ${time4.toFixed(2)}ms - 提升${((time1-time4)/time1*100).toFixed(2)}%`);
    console.log(`async/await优化3: ${time5.toFixed(2)}ms - 提升${((time1-time5)/time1*100).toFixed(2)}%`);
    
    return { 
      original: time1, 
      then: time2, 
      optimized1: time3, 
      optimized2: time4, 
      optimized3: time5 
    };
  }

  // 运行性能测试
  performanceTest().then(results => {
    console.log('\n测试完成！');
  });

    describe("getUsers", function () {

      it("gets users from GitHub", async function () {
        let users = await getUsers(['iliakan', 'remy', 'no.such.users']);
        assert.equal(users[0].login, 'iliakan');
        assert.equal(users[1].login, 'remy');
        assert.equal(users[2], null);
      });

    });
</script>

</html>